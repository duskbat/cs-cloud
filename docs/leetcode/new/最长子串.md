# 最长子串

常用 Map 记录上一个在哪/有没有/有多少

> Map 可以用 array 实现

## 最长子串

### 3. 无重复字符的最长子串 mid

给定一个字符串 s, 请你找出其中不含有重复字符的 最长子串 的长度。

> 记一下 char 上次出现的 idx; 如果 lastIdx >= start, 更新 start, 否则更新 len

=== "Java"

    ```java
    class Solution {
        public int lengthOfLongestSubstring(String s) {
            int[] map = new int[128];
            Arrays.fill(map, -1);
            char[] arr = s.toCharArray();
            int res = 0;
            int start = 0;
            for (int i = 0; i < arr.length; i++) {
                char c = arr[i];
                int lastIdx = map[c];
                if (lastIdx >= start) start = lastIdx + 1;
                else res = Math.max(res, i - start + 1);
                map[c] = i;
            }
            return res;
        }
    }
    ```

=== "Go"

    ```go
    func lengthOfLongestSubstring(s string) int {
        m := map[rune]int{}
        start := 0
        res := 0
        for i, c := range s {
            lastIdx, has := m[c]
            if has && lastIdx >= start {
                start = lastIdx + 1
            } else {
                res = max(res, i-start+1)
            }
            m[c] = i
        }
        return res
    }
    func max(x, y int) int {
        if x < y {
            return y
        }
        return x
    }
    ```

### 5. 最长回文子串 mid

给你一个字符串 s，找到 s 中最长的回文子串。

**解法 1 中心扩散**

> 从头到尾遍历, 每次循环中向两端扩展, 并更新取到最长的 2 个端点; 有指针会很方便

=== "Java"

    ```java
    class Solution {
        public String longestPalindrome(String s) {
            if (s.length() < 2)
                return s;

            char[] chs = s.toCharArray();
            int[] endPoint = new int[] { 0, 0 };
            for (int i = 0; i < chs.length - 1; i++) {
                extendAndJudge(chs, i, 0, endPoint);
                extendAndJudge(chs, i, 1, endPoint);
            }
            return s.substring(endPoint[0], endPoint[1] + 1);
        }

        private void extendAndJudge(char[] arr, int idx, int offset, int[] endPoint) {
            int l = idx, r = idx + offset;
            while (l >= 0 && r < arr.length) {
                if (arr[l] != arr[r])
                    break;
                l--;
                r++;
            }
            l++;
            r--;
            if (r - l > endPoint[1] - endPoint[0]) {
                endPoint[0] = l;
                endPoint[1] = r;
            }
        }
    }
    ```

=== "Go"

    ```go
    func longestPalindrome(s string) string {
        n := len(s)
        var r1, r2 int = 0, 0
        for i := 0; i < n-1; i++ {
            extend(s, i, 0, &r1, &r2)
            extend(s, i, 1, &r1, &r2)
        }
        return s[r1 : r2+1]
    }

    func extend(s string, idx int, offset int, l *int, r *int) {
        i, j := idx, idx+offset
        n := len(s)
        for i >= 0 && j < n {
            if s[i] != s[j] {
                break
            }
            i--
            j++
        }
        // 回退
        i++
        j--
        if *r-*l < j-i {
            *l = i
            *r = j
        }
    }
    ```

**解法 2 manacher**

> manacher 是一个精准且有技巧性的算法, 我们用尽可能少的描述讲清楚它  

> 首先, 回文串存在中心元素为 1 个还是 2 个的差异; 那么, 向元素之间插入相同的 char, 这样新构造出来的字符串就避免了这种差异性  
> 另外, 为方便, 在新构造的字符串左右两侧各自加入 1 个不同的元素"^","$"作为栅栏  
> 不妨设构造后的任意回文串的中心元素的索引为 i, 回文串的半径为臂展(不包含中心元素)

> 在插入 char 之后, 有了一些性质:  
> 1.原回文串最大长度==臂展长度: 例如 len("#1#1#")=2, len("#1#")=1  
> 2.原左端点==(i-臂展)/2: 例如 新构造的左侧为"^#1#", 新的左端点=(i-臂展)=1, 原左端点=1/2=0  

> 然后, 考虑计算每个位置的臂展, 并存在 arm[] 中  
> 臂展的计算, 最朴素的方式就是从中心向两侧扩散, 不过我们有一些技巧性的方式简化  
> 我们从左往右计算每个位置的臂展, 如果当前位置 i 仍然在一个回文串(中心为 core)的覆盖下, 那么, 当前位置 i 跟 j=(2\*core-i)是对称点;  
> 如果 j 完全被回文串覆盖, 可以直接获取到中心为 i 的回文串, 两个回文串是镜像  

> 但是要考虑一些特殊情况:  
> 0.i 没有被长回文串覆盖  
> 1.中心为 j 的回文串没有完全被长回文串覆盖, 也就是说 j 的左臂超出了长回文串的覆盖范围  
> 2.中心为 j 的回文串因为受到端点的限制, 臂展很小  
> 这些情况下, 需要用朴素的方式向两端扩展求出臂展  

> 在求得所有臂展后, 找到最大臂展, 根据上述性质求得最长回文串

$
core 是 right 取最大时 idx 的取值
$

$
core = \mathop{\arg\max(right)}\limits_{idx}
$

```java
class Solution {
    public String longestPalindrome(String s) {
        if (s.isEmpty()) return s;
        char[] arr = preProcess(s);
        int n = arr.length;
        int[] arm = new int[n];
        int core = 0, right = 0; // core 是 right 取到 max 时的 idx
        // 计算臂展
        for (int i = 1; i < n - 1; i++) {
            // j 是 i 关于 core 的对称点
            int j = 2 * core - i;
            // 先转移一下状态
            if (i < right) {
                arm[i] = Math.min(right - i, arm[j]); // 如果j的左臂超过了left, i的右臂先伸展到right
            }
            // 尝试向两边扩
            // 1.i超过了right 2.i的右臂超过了right 3.j的左臂因arr[0]受限很短
            while (arr[i + arm[i] + 1] == arr[i - arm[i] - 1]) {
                arm[i]++;
            }

            // 更新 right
            if (i + arm[i] > right) {
                core = i;
                right = i + arm[i];
            }
        }
        // 找到最大臂展, 求得左右端点
        int idx = 0;
        int len = 0;
        for (int i = 1; i < n - 1; i++) {
            if (arm[i] > len) {
                len = arm[i];
                idx = i;
            }
        }
        // 原左端点==(i-臂展)/2
        // 原最大长度==臂展长度
        int start = (idx - len) / 2;
        return s.substring(start, start + len);
    }

    /**
     * 预处理
     */
    private char[] preProcess(String s) {
        StringBuilder sb = new StringBuilder("^#");
        for (char c : s.toCharArray()) {
            sb.append(c).append("#");
        }
        sb.append("$");
        return sb.toString().toCharArray();
    }
}
```

### 32. 最长有效括号 hard

给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

**解法 1:栈**

> 栈底存储没有被匹配的')'作为分隔符, 栈中存储'('

```java
class Solution {
    public int longestValidParentheses(String s) {
        char[] arr = s.toCharArray();
        Deque<Integer> stack = new LinkedList<>();
        stack.push(-1);
        int res = 0;
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == '(') {
                stack.push(i);
                continue;
            }
            stack.pop();
            if (stack.isEmpty()) {
                // 空栈说明没匹配上
                stack.push(i);
            } else res = Math.max(res, i - stack.element());
        }
        return res;
    }
}
```

**解法 2:DP**

> dp 保存以 i 为结束的子串的最大长度

```java
class Solution {
    public int longestValidParentheses(String s) {
        int max = 0;
        char[] arr = s.toCharArray();
        // 以 i 为结尾的合法区间的长度
        int[] dp = new int[arr.length];
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] == ')') {
                if (arr[i - 1] == '(') {
                    dp[i] = 2 + (i >= 2 ? dp[i - 2] : 0);
                } else {
                    int intervalIdx = i - 1 - dp[i - 1];
                    if (intervalIdx >= 0 && arr[intervalIdx] == '(') {
                        // 非常骚气的赋值
                        dp[i] = dp[i - 1]
                                + 2
                                + (intervalIdx > 0 ? dp[intervalIdx - 1] : 0);
                    }
                }
                max = Math.max(max, dp[i]);
            }
        }
        return max;
    }
}
```

## 最大面积

### 221. 最大正方形 mid

在一个由 '0' 和 '1' 组成的二维矩阵内，找到只包含 '1' 的最大正方形，并返回其面积。

> DP: 右下角坐标为[i][j]的小正方形 的边长  
> $dp[i][j] = 1 + min(dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j])$

```java
class Solution {
    public int maximalSquare(char[][] m) {
        int r = m.length;
        int c = m[0].length;
        int[][] dp = new int[r][c];
        int res = 0;
        for (int i = 0; i < r; i++) {
            if (m[i][0] == '1') {
                dp[i][0] = 1;
                res = 1;
            }
        }
        for (int i = 0; i < c; i++) {
            if (m[0][i] == '1') {
                dp[0][i] = 1;
                res = 1;
            }
        }

        for (int i = 1; i < r; i++) {
            for (int j = 1; j < c; j++) {
                if (m[i][j] == '1') {
                    dp[i][j] = 1 + Math.min(dp[i - 1][j - 1], Math.min(dp[i][j - 1], dp[i - 1][j]));
                    res = Math.max(res, dp[i][j]);
                }
            }
        }
        return res * res;
    }
}
```
