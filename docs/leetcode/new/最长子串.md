# 最长子串

## Tips

技巧
用 map 记录上一个在哪/有没有/有多少

## 最长子串

### 3. 无重复字符的最长子串 mid

给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。

> 记一下 char 上次出现的 idx; 如果 lastIdx >= start, 更新 start, 否则更新 len
> 可以优化 Map

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int[] map = new int[128];
        Arrays.fill(map, -1);
        char[] arr = s.toCharArray();
        int res = 0;
        int start = 0;
        for (int i = 0; i < arr.length; i++) {
            char c = arr[i];
            int lastIdx = map[c];
            if (lastIdx >= start) start = lastIdx + 1;
            else res = Math.max(res, i - start + 1);
            map[c] = i;
        }
        return res;
    }
}
```

```go
func lengthOfLongestSubstring(s string) int {
    m := map[rune]int{}
    start := 0
    res := 0
    for i, c := range s {
        lastIdx, has := m[c]
        if has && lastIdx >= start {
            start = lastIdx + 1
        } else {
            res = max(res, i-start+1)
        }
        m[c] = i
    }
    return res
}
func max(x, y int) int {
    if x < y {
        return y
    }
    return x
}
```

### 5. 最长回文子串 mid

给你一个字符串 s，找到 s 中最长的回文子串。

> 从头到尾遍历, 每次循环中向两端扩展, 并更新取到最长的 2 个端点; 有指针会很方便

```java
class Solution {

    public String longestPalindrome(String s) {
        if (s.length() < 2)
            return s;

        char[] chs = s.toCharArray();
        int[] endPoint = new int[] { 0, 0 };
        for (int i = 0; i < chs.length - 1; i++) {
            extendAndJudge(chs, i, 0, endPoint);
            extendAndJudge(chs, i, 1, endPoint);
        }
        return s.substring(endPoint[0], endPoint[1] + 1);
    }

    private void extendAndJudge(char[] arr, int idx, int offset, int[] endPoint) {
        int l = idx, r = idx + offset;
        while (l >= 0 && r < arr.length) {
            if (arr[l] != arr[r])
                break;
            l--;
            r++;
        }
        l++;
        r--;
        if (r - l > endPoint[1] - endPoint[0]) {
            endPoint[0] = l;
            endPoint[1] = r;
        }
    }
}
```

```go
func longestPalindrome(s string) string {
	n := len(s)
	var r1, r2 int = 0, 0
	for i := 0; i < n-1; i++ {
		extend(s, i, 0, &r1, &r2)
		extend(s, i, 1, &r1, &r2)
	}
	return s[r1 : r2+1]
}

func extend(s string, idx int, offset int, l *int, r *int) {
	i, j := idx, idx+offset
	n := len(s)
	for i >= 0 && j < n {
		if s[i] != s[j] {
			break
		}
		i--
		j++
	}
    // 回退
	i++
	j--
	if *r-*l < j-i {
		*l = i
		*r = j
	}
}
```

### 32. 最长有效括号 hard

给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

**解法 1:栈**

> 栈底存储没有被匹配的')'作为分隔符, 栈中存储'('

```java
class Solution {
    public int longestValidParentheses(String s) {
        char[] arr = s.toCharArray();
        Deque<Integer> stack = new LinkedList<>();
        stack.push(-1);
        int res = 0;
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == '(') {
                stack.push(i);
                continue;
            }
            stack.pop();
            if (stack.isEmpty()) {
                // 空栈说明没匹配上
                stack.push(i);
            } else res = Math.max(res, i - stack.element());
        }
        return res;
    }
}
```

**解法 2:DP**

> dp 保存以 i 为结束的子串的最大长度

```java
class Solution {
    public int longestValidParentheses(String s) {
        int max = 0;
        char[] arr = s.toCharArray();
        // 以 i 为结尾的合法区间的长度
        int[] dp = new int[arr.length];
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] == ')') {
                if (arr[i - 1] == '(') {
                    dp[i] = 2 + (i >= 2 ? dp[i - 2] : 0);
                } else {
                    int intervalIdx = i - 1 - dp[i - 1];
                    if (intervalIdx >= 0 && arr[intervalIdx] == '(') {
                        // 非常骚气的赋值
                        dp[i] = dp[i - 1]
                                + 2
                                + (intervalIdx > 0 ? dp[intervalIdx - 1] : 0);
                    }
                }
                max = Math.max(max, dp[i]);
            }
        }
        return max;
    }
}
```

## 最大面积

### 221. 最大正方形 mid

在一个由 '0' 和 '1' 组成的二维矩阵内，找到只包含 '1' 的最大正方形，并返回其面积。

> DP: 右下角坐标为[i][j]的小正方形 的边长  
> $dp[i][j] = 1 + min(dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j])$

```java
class Solution {
    public int maximalSquare(char[][] m) {
        int r = m.length;
        int c = m[0].length;
        int[][] dp = new int[r][c];
        int res = 0;
        for (int i = 0; i < r; i++) {
            if (m[i][0] == '1') {
                dp[i][0] = 1;
                res = 1;
            }
        }
        for (int i = 0; i < c; i++) {
            if (m[0][i] == '1') {
                dp[0][i] = 1;
                res = 1;
            }
        }

        for (int i = 1; i < r; i++) {
            for (int j = 1; j < c; j++) {
                if (m[i][j] == '1') {
                    dp[i][j] = 1 + Math.min(dp[i - 1][j - 1], Math.min(dp[i][j - 1], dp[i - 1][j]));
                    res = Math.max(res, dp[i][j]);
                }
            }
        }
        return res * res;
    }
}
```
