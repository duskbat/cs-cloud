# 柱子

## 接水

### 11. 盛最多水的容器 mid

给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。

找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

说明：你不能倾斜容器。

> 短板决定了面积, 将短的那一侧向中间移动; 如果两边一样长, 那么只移动一侧面积都不会更大, 所以移动两端

```java
class Solution {
    public int maxArea(int[] height) {
        int p1 = 0, p2 = height.length - 1;
        int res = 0;
        while (p1 < p2) {
            int square;
            if (height[p1] < height[p2])
                square = height[p1] * (p2 - p1++);
            else if (height[p1] > height[p2])
                square = height[p2] * (p2-- - p1);
            else
                square = height[p1] * (p2-- - p1++);
            res = Math.max(res, square);
        }
        return res;
    }
}
```

### 42. 接雨水 hard

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
> 单调栈

```java
class Solution {
    public int trap(int[] height) {
        int n = height.length;
        int res = 0;
        Deque<Integer> stack = new ArrayDeque<>();
        for (int i = 0; i < n; i++) {
            while (!stack.isEmpty() && height[i] > height[stack.element()]) {
                Integer t1 = stack.pop();
                if (stack.isEmpty()) break;
                int t2 = stack.element();
                int currWidth = i - t2 - 1;
                int currHeight = Math.min(height[t2], height[i]) - height[t1];
                res += currWidth * currHeight;
            }
            stack.push(i);
        }
        return res;
    }
}
```

## 柱子面积

### 84. 柱状图中最大的矩形 hard

给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

> 中心扩展暴力枚举会超时, 找下一个和前一个更小元素

```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        int n = heights.length;
        int[] left = new int[n];
        int[] right = new int[n];
        Arrays.fill(right, n - 1);
        Deque<Integer> stack = new ArrayDeque<>();
        for (int i = 0; i < n; i++) {
            while (!stack.isEmpty() && heights[i] < heights[stack.element()]) {
                right[stack.pop()] = i - 1;
            }
            // 此时 stack 中的数据形状 ^ => /
            // 栈顶元素就是 left[i]
            if (!stack.isEmpty()) left[i] = stack.element() + 1;
            stack.push(i);
        }
        int res = 0;
        for (int i = 0; i < n; i++) {
            res = Math.max(res, (right[i] - left[i] + 1) * heights[i]);
        }
        return res;
    }
}
```

### 85. 最大矩形 hard

给定一个仅包含 0 和 1, 大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。

```java
class Solution {
    public int maximalRectangle(char[][] matrix) {
        int r = matrix.length;
        if (r == 0) return 0;
        int c = matrix[0].length;
        int[][] len = new int[r][c];
        for (int i = 0; i < r; i++) {
            len[i][0] = matrix[i][0] == '1' ? 1 : 0;
            for (int j = 1; j < c; j++) {
                if (matrix[i][j] == '1') {
                    len[i][j] = len[i][j - 1] + 1;
                }
            }
        }
        int res = 0;
        for (int j = 0; j < c; j++) {
            int[] up = new int[r];
            int[] down = new int[r];
            Arrays.fill(down, r - 1);
            // 单调增
            Deque<Integer> stack = new ArrayDeque<>();
            // 从上到下
            for (int i = 0; i < r; i++) {
                while (!stack.isEmpty() && len[i][j] < len[stack.element()][j]) {
                    Integer hIdx = stack.pop();
                    down[hIdx] = i - 1;
                }
                // 里面大的都移除了
                if (!stack.isEmpty()) up[i] = stack.element() + 1;
                stack.push(i);
            }

            for (int i = 0; i < r; i++) {
                int height = down[i] - up[i] + 1;
                int area = height * len[i][j];
                res = Math.max(res, area);
            }
        }
        return res;
    }
}
```