# 字符串匹配

## 匹配子串

### 10. 正则表达式匹配 hard

给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '\*' 的正则表达式匹配。  
Given an input string s and a pattern p, implement regular expression matching with support for '.' and '\*' where:

-   '.' 匹配任意单个字符  
    '.' Matches any single character.​​​​
-   '\*' 匹配零个或多个前面的那一个元素  
    '\*' Matches zero or more of the preceding element.

所谓匹配，是要涵盖 整个 字符串 s 的，而不是部分字符串。  
The matching should cover the entire input string (not partial).

> 此题可以通过动态规划或者有限状态自动机做, 但我选择调库

=== "Java"

    ```java
    class Solution {
        public boolean isMatch(String s, String p) {
            return s.matches(p);
        }
    }
    ```

=== "Go"

    ```go
    func isMatch(s, p string) bool {
        res, _ := regexp.MatchString("^"+p+"$", s)
        return res
    }
    ```

### 28. 找出字符串中第一个匹配项的下标 easy

给你两个字符串 haystack 和 needle，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回 -1。  
Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

> 经典的字符串单模匹配模型有很多, 如 Knuth-Morris-Pratt 算法、Boyer-Moore 算法、Sunda 算法等

**解法 1 暴力**

```java
class Solution {
    public int strStr(String s1, String s2) {
        // 求索引位置, 在尾部, 当i取n-1时, S2取得倒数第1个, 倒数第m个是起始位
        for (int i = 0; i < s1.length() + 1 - s2.length(); i++) {
            if (check(s1, s2, i)) return i;
        }
        return -1;
    }

    private boolean check(String s1, String s2, int idx) {
        int i = idx, j = 0;
        for (; j < s2.length(); i++, j++) {
            if (s1.charAt(i) != s2.charAt(j)) return false;
        }
        return true;
    }
}
```

**解法 2 KMP**

> KMP 算法的核心在于前缀函数.  
> 前缀函数的定义可以用一个数组表示: `arr[i]` = 当字符串 $S_i$ 的真前缀==真后缀时, 前后缀长度的最大值  
> 如何求解前缀函数呢? 朴素做法是:

```c++
// 从前往后计算每个子串的前缀函数
for (int i = 1; i < n; i++)
    // 长度 j 从最长开始尝试
    for (int j = i; j >= 0; j--)
      // 字符串匹配
      if (s.substr(0, j) == s.substr(i - j + 1, j)) {
        pi[i] = j;
        break;
      }
```

> 优化 1:  
> 性质 $π(i)<=π(i−1)+1$ 是比较显然的

```c++
// 从前往后计算每个子串前缀函数
for (int i = 1; i < n; i++)
    // 长度 j 从前一个状态转移
    for (int j = pi[i - 1] + 1; j >= 0; j--)  // improved: j=i => j=pi[i-1]+1
      if (s.substr(0, j) == s.substr(i - j + 1, j)) {
        pi[i] = j;
        break;
      }
```

> 优化 2:
>
> 1. 由 $π(i)$ 定义得: $s[0:π(i)−1]=s[i−π(i)+1:i]$ 注意此处切片左右端点都包含;
> 2. 如果 $s[i]=s[π(i−1)]$, 也就是说新位置的长度能从前一个位置的长度+1  
>    则 $π(i)=π(i−1)+1$

> 依据这个性质提出求解 $π(i)$ 的方案：找到最大的 j，满足 $s[0:j−1]=s[i−(j-1)+1:i−1]$ 且 $s[i]=s[j]$;  
> 从 $j = π[i - 1]$ 开始找, 找不到则 $j = π[j - 1]$ 回退;

```c++
for (int i = 1; i < n; i++) {
    int j = pi[i - 1];
    while (j > 0 && s[i] != s[j]) j = pi[j - 1];
    if (s[i] == s[j]) j++;
    pi[i] = j;
}
```

> 然后拼接 pattern, "#", S; 从 $S_0$ 开始找, 只要找到 π(i) >= pattern 的 i

```java
class Solution {
    public int strStr(String haystack, String needle) {
        int n = haystack.length(), m = needle.length();
        String str = needle + "#" + haystack;
        int s = str.length();
        if (m == 0) return 0;
        int[] pi = new int[s];
        for (int i = 1; i < s; i++) {
            int j = pi[i - 1];
            while (j > 0 && str.charAt(i) != str.charAt(j)) {
                j = pi[j - 1];
            }
            if (str.charAt(i) == str.charAt(j)) {
                j++;
            }
            pi[i] = j;
            if (j >= m) break;
        }
        System.out.println(Arrays.toString(pi));
        for (int i = 0; i < s; i++) {
            if (pi[i] == m) {
                // i - m + 1 => # 的 next; # == m
                return i - m + 1 - (m + 1);
            }
        }
        return -1;
    }
}
```

## 同构

### 205. 同构字符串 easy

给定两个字符串 s 和 t，判断它们是否是同构的。

如果 s 中的字符可以按某种映射关系替换得到 t，那么这两个字符串是同构的。

每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。

> 要映射 2 次, 防止一对多和多对一

```java
class Solution {
    public boolean isIsomorphic(String s, String t) {
        if (s.length() != t.length()) return false;
        Character[] m1 = new Character[128];
        Character[] m2 = new Character[128];
        for (int i = 0; i < s.length(); i++) {
            Character c1 = s.charAt(i);
            Character c2 = t.charAt(i);
            Character c3 = m1[c1];
            Character c4 = m2[c2];
            if (c3 == null && c4 == null) {
                m1[c1] = c2;
                m2[c2] = c1;
            }
            //
            else if (!(c1.equals(c4) && c2.equals(c3))) return false;
        }
        return true;
    }
}
```
